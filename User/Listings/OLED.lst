C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN .\Objects\OLED.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Hardware\OLED.C OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Hardware) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\OLED.lst) TABS(2) OBJECT(.\Objects\OLED.obj)

line level    source

   1          #include <STC12C5A60S2.H>
   2          #include "OLED.H"
   3          #include "OLEDFONT.H"
   4          #include "OLEDBMP.H"
   5          #include "IIC.H"
   6          #include "DS1302.H"
   7          #include <stdio.h>
   8          #include <intrins.h>
   9          #include <stdarg.h>
  10          u8 (*Ezk_1)[6]  = F6x8;
  11          u8 (*Ezk_2)[16] = F8x16;
  12          u8 (*Czk_1)[32]  = Hzk16x16;
  13          u8 (*Czk_2)[24]  = Hzk12x12;
  14          
  15          void OLED_Init(void)
  16          {
  17   1        OLED_WR_Byte(0xAE,OLED_CMD);//--display off
  18   1        OLED_WR_Byte(0x00,OLED_CMD);//---设置显示位置―列低地址
  19   1        OLED_WR_Byte(0x10,OLED_CMD);//---设置显示位置―列高地址 
  20   1        OLED_WR_Byte(0x40,OLED_CMD);//--set start line address  
  21   1        OLED_WR_Byte(0xB0,OLED_CMD);//--set page address
  22   1        OLED_WR_Byte(0x81,OLED_CMD); // contract control
  23   1        OLED_WR_Byte(0xFF,OLED_CMD);//--128   
  24   1        OLED_WR_Byte(0xA1,OLED_CMD);//set segment remap 
  25   1        OLED_WR_Byte(0xA6,OLED_CMD);//--normal / reverse
  26   1        OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)
  27   1        OLED_WR_Byte(0x3F,OLED_CMD);//--1/32 duty
  28   1        OLED_WR_Byte(0xC8,OLED_CMD);//Com scan direction
  29   1        OLED_WR_Byte(0xD3,OLED_CMD);//-set display offset
  30   1        OLED_WR_Byte(0x00,OLED_CMD);//  
  31   1        OLED_WR_Byte(0xD5,OLED_CMD);//set osc division
  32   1        OLED_WR_Byte(0x80,OLED_CMD);//  
  33   1        OLED_WR_Byte(0xD8,OLED_CMD);//set area color mode off
  34   1        OLED_WR_Byte(0x05,OLED_CMD);//  
  35   1        OLED_WR_Byte(0xD9,OLED_CMD);//Set Pre-Charge Period
  36   1        OLED_WR_Byte(0xF1,OLED_CMD);//  
  37   1        OLED_WR_Byte(0xDA,OLED_CMD);//set com pin configuartion
  38   1        OLED_WR_Byte(0x12,OLED_CMD);//
  39   1        OLED_WR_Byte(0xDB,OLED_CMD);//set Vcomh
  40   1        OLED_WR_Byte(0x30,OLED_CMD);//  
  41   1        OLED_WR_Byte(0x8D,OLED_CMD);//set charge pump enable
  42   1        OLED_WR_Byte(0x14,OLED_CMD);//  
  43   1        OLED_WR_Byte(0xAF,OLED_CMD);//--turn on oled panel
  44   1        
  45   1        OLED_Clear();
  46   1      }
  47          /**********************************************
  48          // IIC Write Command
  49          **********************************************/
  50          void OLED_Write_IIC_Command(unsigned char IIC_Command)
  51          {
  52   1        IIC_Start();
  53   1        Write_IIC_Byte(0x78);            //Slave address,SA0=0
  54   1        IIC_Wait_Ack(); 
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 2   

  55   1        Write_IIC_Byte(0x00);     //write command
  56   1        IIC_Wait_Ack(); 
  57   1        Write_IIC_Byte(IIC_Command); 
  58   1        IIC_Wait_Ack(); 
  59   1        IIC_Stop();
  60   1      }
  61          /**********************************************
  62          // IIC Write Data
  63          **********************************************/
  64          void OLED_Write_IIC_Date(unsigned char IIC_Data)
  65          {
  66   1        IIC_Start();
  67   1        Write_IIC_Byte(0x78);     //D/C#=0; R/W#=0
  68   1        IIC_Wait_Ack(); 
  69   1        Write_IIC_Byte(0x40);     //write data
  70   1        IIC_Wait_Ack(); 
  71   1        Write_IIC_Byte(IIC_Data);
  72   1        IIC_Wait_Ack(); 
  73   1        IIC_Stop();
  74   1      }
  75          void OLED_WR_Byte(unsigned dat,unsigned cmd)
  76          {
  77   1        if(cmd)
  78   1        {
  79   2          OLED_Write_IIC_Date(dat); 
  80   2        }
  81   1        else 
  82   1        {
  83   2          OLED_Write_IIC_Command(dat);
  84   2        }
  85   1      }
  86          
  87          //反显函数
  88          void OLED_ColorTurn(u8 mode)
  89          {
  90   1        if(mode==0)
  91   1        {
  92   2          OLED_WR_Byte(0xA6,OLED_CMD);//正常显示
  93   2        }
  94   1        if(mode==1)
  95   1        {
  96   2          OLED_WR_Byte(0xA7,OLED_CMD);//反色显示
  97   2        }
  98   1      }
  99          //屏幕旋转180度
 100          void OLED_DisplayTurn(u8 mode)
 101          {
 102   1          if(mode==0)
 103   1              {
 104   2                  OLED_WR_Byte(0xC8,OLED_CMD);//正常显示
 105   2                  OLED_WR_Byte(0xA1,OLED_CMD);
 106   2              }
 107   1          if(mode==1)
 108   1              {
 109   2                  OLED_WR_Byte(0xC0,OLED_CMD);//反转显示
 110   2                  OLED_WR_Byte(0xA0,OLED_CMD);
 111   2              }
 112   1      }
 113          //坐标设置
 114          void OLED_Set_Pos(unsigned char x, unsigned char y) 
 115          { 
 116   1        OLED_WR_Byte(0xb0+y,OLED_CMD);
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 3   

 117   1        OLED_WR_Byte(((x&0xf0)>>4)|0x10,OLED_CMD);
 118   1        OLED_WR_Byte((x&0x0f),OLED_CMD); 
 119   1      }       
 120          //开启OLED显示    
 121          void OLED_Display_On(void)
 122          {
 123   1        OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
 124   1        OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON
 125   1        OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON
 126   1      }
 127          //关闭OLED显示     
 128          void OLED_Display_Off(void)
 129          {
 130   1        OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
 131   1        OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF
 132   1        OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF
 133   1      }            
 134          //清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!    
 135          void OLED_Clear(void)  
 136          {  
 137   1        u8 i,n;       
 138   1        for(i=0;i<8;i++)  
 139   1        {  
 140   2          OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）
 141   2          OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置―列低地址
 142   2          OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置―列高地址   
 143   2          for(n=0;n<128;n++)OLED_WR_Byte(0,OLED_DATA); 
 144   2        } //更新显示
 145   1      }
 146          void OLED_On(void)  
 147          {  
 148   1        u8 i,n;       
 149   1        for(i=0;i<8;i++)  
 150   1        {  
 151   2          OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）
 152   2          OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置―列低地址
 153   2          OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置―列高地址   
 154   2          for(n=0;n<128;n++)OLED_WR_Byte(1,OLED_DATA); 
 155   2        } //更新显示
 156   1      }
 157          
 158          //在指定位置显示一个字符,包括部分字符
 159          //x:0~127
 160          //y:0~63       
 161          //sizey:选择字体 8 
 162          void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 sizey,u8 mode)
 163          {
 164   1        u8 c=0,sizex=sizey/2;
 165   1        u16 i=0,size1;
 166   1        if(sizey==8)size1=6;
 167   1        else size1=(sizey/8+((sizey%8)?1:0))*(sizey/2);
 168   1        c=chr-' ';//得到偏移后的值
 169   1        OLED_Set_Pos(x,y);
 170   1        if(mode==1)
 171   1        {
 172   2          for(i=0;i<size1;i++)
 173   2          {
 174   3              if(i%sizex==0&&sizey!=8) OLED_Set_Pos(x,y++);
 175   3              if(sizey==8) OLED_WR_Byte(Ezk_1[c][i],OLED_DATA);//6X8字号
 176   3              else if(sizey==16) OLED_WR_Byte(Ezk_2[c][i],OLED_DATA);//8x16字号
 177   3      //        else if(sizey==xx) OLED_WR_Byte(asc2_xxxx[c][i],OLED_DATA);//用户添加字号
 178   3              else return;
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 4   

 179   3          }
 180   2        }
 181   1        else if(mode==0)
 182   1        {
 183   2          for(i=0;i<size1;i++)
 184   2          {
 185   3              if(i%sizex==0&&sizey!=8) OLED_Set_Pos(x,y++);
 186   3              if(sizey==8) OLED_WR_Byte(~Ezk_1[c][i],OLED_DATA);//6X8字号
 187   3              else if(sizey==16) OLED_WR_Byte(~Ezk_2[c][i],OLED_DATA);//8x16字号
 188   3      //        else if(sizey==xx) OLED_WR_Byte(asc2_xxxx[c][i],OLED_DATA);//用户添加字号
 189   3              else return;
 190   3          }
 191   2        }
 192   1          
 193   1      }
 194          //m^n函数
 195          u32 oled_pow(u8 m,u8 n)
 196          {
 197   1        u32 result=1;  
 198   1        while(n--)result*=m;//计算    
 199   1        return result;//有返回值的子函数
 200   1      } 
 201          
 202          //显示数字
 203          //x,y :起点坐标  
 204          //len :数字的位数
 205          //sizey:字体大小
 206          //num:数值(0~4294967295);       
 207          void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 sizey,u8 mode)
 208          {
 209   1        u8 t,temp,m=0;
 210   1        u8 enshow=0;
 211   1        if(sizey==8)m=2;
 212   1        for(t=0;t<len;t++)
 213   1        {
 214   2          temp=(num/oled_pow(10,len-t-1))%10;
 215   2          if(enshow==0&&t<(len-1))
 216   2          {
 217   3            if(temp==0)
 218   3            {
 219   4              OLED_ShowChar(x+(sizey/2+m)*t,y,' ',sizey,mode);
 220   4              continue;
 221   4            }else enshow=1;
 222   3          }OLED_ShowChar(x+(sizey/2+m)*t,y,temp+'0',sizey,mode);
 223   2        }
 224   1      } 
 225          
 226          //显示一个字符号串
 227          //显示的横坐标、纵坐标、字符串、字体大小
 228          void OLED_ShowString(u8 x,u8 y,u8 *chr,u8 sizey,u8 mode)
 229          {
 230   1        u8 j=0;
 231   1        while (chr[j]!='\0')
 232   1        {
 233   2          OLED_ShowChar(x,y,chr[j++],sizey,mode);
 234   2          if(sizey==8)x+=6;
 235   2          else x+=sizey/2;
 236   2        }
 237   1      }
 238          //显示汉字，可显示取模后的任意点阵
 239          //参数：显示的横坐标、纵坐标、汉字库中文字的序号、汉字尺寸（默认16x16）mode：0反色 1正常
 240          //显示汉字，可显示取模后的任意点阵
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 5   

 241          //参数：显示的横坐标、纵坐标、汉字库中文字的序号、汉字尺寸（默认16x16）
 242          void OLED_ShowChinese(u8 x,u8 y,u8 no,u8 sizey,u8 mode)
 243          {
 244   1          u16 i,size1=(sizey/8+((sizey%8)?1:0))*sizey;
 245   1          if(mode==1)
 246   1          {
 247   2            for(i=0;i<size1;i++)
 248   2            {
 249   3              if(i%sizey==0) OLED_Set_Pos(x,y++);
 250   3              if(sizey==16) OLED_WR_Byte(Czk_1[no][i],OLED_DATA);//16x16字号
 251   3              else if(sizey==12) OLED_WR_Byte(Czk_2[no][i],OLED_DATA);//用户添加字号
 252   3      //        else if(sizey==xx) OLED_WR_Byte(xxx[no][i],OLED_DATA);//用户添加字号
 253   3              else return;
 254   3            }  
 255   2          }
 256   1          else if(mode==0)
 257   1          {
 258   2            for(i=0;i<size1;i++)
 259   2            {
 260   3              if(i%sizey==0) OLED_Set_Pos(x,y++);
 261   3              if(sizey==16) OLED_WR_Byte(~Czk_1[no][i],OLED_DATA);//16x16字号
 262   3              else if(sizey==12) OLED_WR_Byte(~Czk_2[no][i],OLED_DATA);//用户添加字号
 263   3      //        else if(sizey==xx) OLED_WR_Byte(xxx[no][i],OLED_DATA);//用户添加字号
 264   3              else return;
 265   3            }  
 266   2          }
 267   1      }
 268          
 269          //显示图片
 270          //x,y显示坐标
 271          //sizex,sizey,图片长宽
 272          //BMP：要显示的图片
 273          void OLED_DrawBMP(u8 x,u8 y,u8 sizex,u8 sizey,u8 BMP[])
 274          {
 275   1        u16 j=0;
 276   1        u8 i,m;
 277   1        sizey=sizey/8+((sizey%8)?1:0);
 278   1        for(i=0;i<sizey;i++)
 279   1        {
 280   2          OLED_Set_Pos(x,i+y);
 281   2          for(m=0;m<sizex;m++)
 282   2          {
 283   3            OLED_WR_Byte(BMP[j++],OLED_DATA);
 284   3          }
 285   2        }
 286   1      }
 287          //DS1302时间显示
 288          void OLED_TimeShow(bit setting,u8 TimeSelect)
 289          {
 290   1        u8 i,x,y;
 291   1        bit flag;
 292   1        
 293   1        if(setting==0)
 294   1        {
 295   2          OLED_ShowChar( 80,6,'-',8,1);
 296   2          OLED_ShowChar(104,6,'-',8,1);
 297   2          OLED_ShowChar( 80,7,':',8,1);
 298   2          OLED_ShowChar(104,7,':',8,1);
 299   2        
 300   2          for(i=0;i<6;i++)
 301   2          {
 302   3            x=64+24*(i%3);//确定x坐标
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 6   

 303   3            y=6+((i/3)>=1);//确定是在第6行还是第7行显示
 304   3            if(DS1302_Time[i]>=10){OLED_ShowNum(x,y,DS1302_Time[i],2,8,1);}
 305   3            else
 306   3            {//小于10补零
 307   4              OLED_ShowNum(x,y,0,1,8,1);
 308   4              OLED_ShowNum(x+6,y,DS1302_Time[i],1,8,1);
 309   4            }
 310   3          }
 311   2        }
 312   1        else if(setting==1)
 313   1        {
 314   2          OLED_ShowChinese(80,6,21,16,1);
 315   2          OLED_ShowChar(40,2,'-',16,1);
 316   2          OLED_ShowChar(80,2,'-',16,1);
 317   2          OLED_ShowChar(40,4,':',16,1);
 318   2          OLED_ShowChar(80,4,':',16,1);
 319   2        
 320   2          for(i=0;i<6;i++)
 321   2          {
 322   3            if(i==TimeSelect){flag=0;}
 323   3            else{flag=1;}
 324   3            x=16+40*(i%3);//确定x坐标
 325   3            y=2+2*((i/3)>=1);//确定是在第6行还是第7行显示
 326   3            if(DS1302_Time[i]>=10){OLED_ShowNum(x,y,DS1302_Time[i],2,16,flag);}
 327   3            else
 328   3            {//小于10补零
 329   4              OLED_ShowNum(x,y,0,1,16,flag);
 330   4              OLED_ShowNum(x+8,y,DS1302_Time[i],1,16,flag);
 331   4            }
 332   3          }
 333   2        }
 334   1        
 335   1      }
 336          
 337          //秒表计时显示
 338          void OLED_StopwatchShow()
 339          {
 340   1        
 341   1        if(Min<10){OLED_ShowString(32,4,"0",8,1);OLED_ShowNum(38,4,Min,1,8,1);}//分
 342   1        else{OLED_ShowNum(32,4,Min,2,8,1);}
 343   1        OLED_ShowChar(46,4,':',8,1);
 344   1        
 345   1        if(Sec<10){OLED_ShowString(54,4,"0",8,1);OLED_ShowNum(60,4,Sec,1,8,1);}//秒
 346   1        else{OLED_ShowNum(54,4,Sec,2,8,1);}
 347   1        OLED_ShowChar(68,4,'.',8,1);
 348   1        
 349   1        if(Msec<10){OLED_ShowString(76,4,"0",8,1);OLED_ShowNum(82,4,Msec,1,8,1);}//毫秒
 350   1        else{OLED_ShowNum(76,4,Msec,2,8,1);}
 351   1        
 352   1      }
 353          
 354          void OLED_Background1(u8 mode)//背景显示1-----功能：主菜单
 355          {
 356   1        if(mode==10)
 357   1        {
 358   2          OLED_ShowChinese(00,00,00,16,0);//秒
 359   2          OLED_ShowChinese(16,00,01,16,0);//表
 360   2          OLED_ShowChinese(00,02,02,16,1);//时
 361   2          OLED_ShowChinese(16,02,03,16,1);//控
 362   2          OLED_ShowChinese(00,04,10,16,1);//设
 363   2          OLED_ShowChinese(16,04,11,16,1);//置
 364   2        }
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 7   

 365   1        if(mode==12)
 366   1        {
 367   2          OLED_ShowChinese(00,00,00,16,1);//秒
 368   2          OLED_ShowChinese(16,00,01,16,1);//表
 369   2          OLED_ShowChinese(00,02,02,16,0);//时
 370   2          OLED_ShowChinese(16,02,03,16,0);//控
 371   2          OLED_ShowChinese(00,04,10,16,1);//设
 372   2          OLED_ShowChinese(16,04,11,16,1);//置
 373   2        }
 374   1        if(mode==14)
 375   1        {
 376   2          OLED_ShowChinese(00,00,00,16,1);//秒
 377   2          OLED_ShowChinese(16,00,01,16,1);//表
 378   2          OLED_ShowChinese(00,02,02,16,1);//时
 379   2          OLED_ShowChinese(16,02,03,16,1);//控
 380   2          OLED_ShowChinese(00,04,10,16,0);//设
 381   2          OLED_ShowChinese(16,04,11,16,0);//置
 382   2        }
 383   1      }               
 384          
 385          
 386          
 387          void OLED_Background20()//背景显示2_1--------功能：秒表
 388          {
 389   1        OLED_ShowChinese(00,00,12,16,1);//按
 390   1        OLED_ShowChinese(16,00,13,16,1);//下
 391   1        OLED_ShowString( 32,0,"key1",16,1);
 392   1        OLED_ShowChinese(64,00,14,16,1);//以
 393   1        OLED_ShowChinese(80,00,04,16,1);//开
 394   1        OLED_ShowChinese(96,00,05,16,1);//始
 395   1      }             
 396          void OLED_Background22()//背景显示2_2--------功能：设置时间控制
 397          {
 398   1        OLED_ShowChinese(00,00,15,16,1);//请
 399   1        OLED_ShowChinese(16,00,10,16,1);//设
 400   1        OLED_ShowChinese(32,00,11,16,1);//置
 401   1        OLED_ShowChinese(48,00,02,16,1);//时
 402   1        OLED_ShowChinese(64,00,16,16,1);//间
 403   1        OLED_ShowChinese(32,02,02,16,1);//时
 404   1        OLED_ShowChinese(64,02, 9,16,1);//分
 405   1        OLED_ShowChinese(96,02,00,16,1);//秒
 406   1      }
 407          void OLED_Background24()//背景显示2_3--------功能：外设设置
 408          { 
 409   1        bit bSelect0;
 410   1        bit bSelect1;
 411   1        bit bSelect2;
 412   1        if(MenuSet_flag==0){bSelect0=0;bSelect1=1;bSelect2=1;}
 413   1        if(MenuSet_flag==1){bSelect0=1;bSelect1=0;bSelect2=1;}
 414   1        if(MenuSet_flag==2){bSelect0=1;bSelect1=1;bSelect2=0;}
 415   1        
 416   1        OLED_ShowChinese(00,00,02,16,bSelect0);//时
 417   1        OLED_ShowChinese(16,00,16,16,bSelect0);//
 418   1        OLED_ShowChinese(32,00,10,16,bSelect0);//设
 419   1        OLED_ShowChinese(48,00,11,16,bSelect0);//置
 420   1        
 421   1        
 422   1        OLED_ShowChinese(00,02,17,16,bSelect1);//音
 423   1        OLED_ShowChinese(16,02,18,16,bSelect1);//量
 424   1        OLED_ShowChinese(32,02,10,16,bSelect1);//设
 425   1        OLED_ShowChinese(48,02,11,16,bSelect1);//置
 426   1        
C51 COMPILER V9.60.7.0   OLED                                                              11/29/2024 17:30:57 PAGE 8   

 427   1        OLED_ShowChinese(00,04,24,16,bSelect2);//音
 428   1        OLED_ShowChinese(16,04,25,16,bSelect2);//量
 429   1        OLED_ShowChinese(32,04,10,16,bSelect2);//设
 430   1        OLED_ShowChinese(48,04,11,16,bSelect2);//置
 431   1        
 432   1      } 
 433          
 434          void OLED_SetVolume()
 435          {
 436   1        OLED_ShowChinese(00,00,17,16,1);//音
 437   1        OLED_ShowChinese(16,00,18,16,1);//量
 438   1        OLED_ShowChinese(32,00,19,16,1);//等
 439   1        OLED_ShowChinese(48,00,20,16,1);//级
 440   1        OLED_ShowChar( 64,00,':',16,1);
 441   1      }
 442          
 443          void OLED_Lock()
 444          {
 445   1        u8  i;
 446   1        u8  uSelect[4];
 447   1        OLED_ShowChinese(00,00,15,16,1);//请
 448   1        OLED_ShowChinese(48,00,24,16,1);//密
 449   1        OLED_ShowChinese(64,00,25,16,1);//码
 450   1        if(bLock_Set==0)
 451   1        {
 452   2          OLED_ShowChinese(16,00,22,16,1);//输
 453   2          OLED_ShowChinese(32,00,23,16,1);//入
 454   2        }
 455   1        else if(bLock_Set==1)
 456   1        {
 457   2          OLED_ShowChinese(16,00,26,16,1);//修
 458   2          OLED_ShowChinese(32,00,27,16,1);//改
 459   2        }
 460   1        
 461   1        
 462   1        
 463   1        for(i=0;i<4;i++)
 464   1        {
 465   2          if(i==cLockSelect){uSelect[i]=0;}
 466   2          else{uSelect[i]=1;}
 467   2          
 468   2        }
 469   1        OLED_ShowNum(00,2,nLockNum/1000,2,16,uSelect[0]);
 470   1        OLED_ShowNum(16,2,nLockNum/100%10,2,16,uSelect[1]);
 471   1        OLED_ShowNum(32,2,nLockNum/10%10,2,16,uSelect[2]);
 472   1        OLED_ShowNum(48,2,nLockNum%10,2,16,uSelect[3]);
 473   1        
 474   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3299    ----
   CONSTANT SIZE    =   4143    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12      71
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       5
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
